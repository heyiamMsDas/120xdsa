ðŸ”¹ What the code does?
It finds the Longest Common Subsequence (LCS) of two strings and prints that subsequence.

ðŸ”¹ Steps:

vector<vector<int>> dp(n+1 , vector<int>(m+1 , 0));


Make a DP table of size (n+1) x (m+1) where
dp[i][j] = length of LCS of s1[0..i-1] and s2[0..j-1].

Fill DP table

if(s1[i-1] == s2[j-1])
    dp[i][j] = 1 + dp[i-1][j-1];
else
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);


If characters match â†’ extend LCS by 1.

Else â†’ take best from ignoring one char from either string.

Length of LCS

int len = dp[n][m];


Final answer length is bottom-right of DP.

Reconstruct LCS (Backtracking)

while(i > 0 && j > 0) {
    if(s1[i-1] == s2[j-1]) { ... }
    else if(dp[i-1][j] > dp[i][j-1]) i--;
    else j--;
}


Start from bottom-right and move backwards:

If chars match â†’ put in answer.

Else â†’ move towards the larger neighbor.

Result

return ans;


You get the actual subsequence, not just its length.

ðŸ”¹ Example

s1 = "abcde", s2 = "bde"

DP builds lengths step by step.

Backtracking gives "bde".

âš¡ In one line:
ðŸ‘‰ Build DP table for lengths â†’ then backtrack to construct the actual LCS string.